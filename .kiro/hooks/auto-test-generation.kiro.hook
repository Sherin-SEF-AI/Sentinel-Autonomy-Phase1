{
  "enabled": true,
  "name": "Auto Test File Generator",
  "description": "When a new Python module file is created in src/**, automatically create a corresponding test file in tests/unit/ with the same name prefixed with \"test_\". The test file includes imports, test class, pytest fixtures for mock configuration and instance creation, and test methods for initialization, happy path, edge cases, and performance (< 50ms assertion).",
  "version": "1",
  "when": {
    "type": "fileEdited",
    "patterns": [
      "src/**/*.py"
    ]
  },
  "then": {
    "type": "askAgent",
    "prompt": "A new Python module has been created at: {{filePath}}\n\nPlease generate a corresponding test file following these requirements:\n\n1. **File Location**: Create the test file in tests/unit/ with the name \"test_\" + the module path converted to underscores\n   - Example: src/camera/capture.py → tests/unit/test_camera_capture.py\n   - Example: src/perception/bev/transformer.py → tests/unit/test_perception_bev_transformer.py\n\n2. **Test File Structure**:\n   ```python\n   \"\"\"Test suite for {{moduleName}} module.\"\"\"\n   \n   import pytest\n   from unittest.mock import Mock, patch, MagicMock\n   from {{importPath}} import {{className}}\n   \n   \n   @pytest.fixture\n   def mock_config():\n       \"\"\"Fixture providing mock configuration for testing.\"\"\"\n       config = Mock()\n       # Add relevant config attributes based on the module\n       return config\n   \n   \n   @pytest.fixture\n   def {{instanceName}}(mock_config):\n       \"\"\"Fixture creating an instance of {{className}} for testing.\"\"\"\n       return {{className}}(mock_config)\n   \n   \n   class Test{{className}}:\n       \"\"\"Test suite for {{className}} class.\"\"\"\n       \n       def test_initialization(self, {{instanceName}}, mock_config):\n           \"\"\"Test that {{className}} initializes correctly with valid configuration.\"\"\"\n           assert {{instanceName}} is not None\n           # Add assertions for initialization state\n       \n       def test_main_function_happy_path(self, {{instanceName}}):\n           \"\"\"Test main functionality with valid inputs and expected behavior.\"\"\"\n           # Test the primary method/function with typical inputs\n           pass\n       \n       def test_main_function_edge_cases(self, {{instanceName}}):\n           \"\"\"Test main functionality with edge cases and boundary conditions.\"\"\"\n           # Test with None, empty inputs, extreme values, etc.\n           pass\n       \n       @pytest.mark.performance\n       def test_performance(self, {{instanceName}}):\n           \"\"\"Test that execution completes within performance requirements (< 50ms).\"\"\"\n           import time\n           \n           start_time = time.perf_counter()\n           # Execute the main function\n           end_time = time.perf_counter()\n           \n           execution_time_ms = (end_time - start_time) * 1000\n           assert execution_time_ms < 50, f\"Execution took {execution_time_ms:.2f}ms, expected < 50ms\"\n   ```\n\n3. **Analyze the source file** at {{filePath}} to:\n   - Identify the main class name(s) to import\n   - Determine appropriate mock configuration attributes based on the module's dependencies\n   - Identify the primary methods to test\n   - Add specific assertions relevant to the module's functionality\n\n4. **Follow pytest best practices**:\n   - Use descriptive docstrings for each test method\n   - Use appropriate pytest decorators (@pytest.mark.performance, @pytest.mark.parametrize if needed)\n   - Mock external dependencies (file I/O, network, GPU operations, camera access)\n   - Test both success and failure paths\n\n5. **Technology-specific considerations**:\n   - Mock PyTorch models and CUDA operations\n   - Mock OpenCV camera capture and image operations\n   - Mock file system operations for config/model loading\n   - Use appropriate fixtures for NumPy arrays and tensors\n\nCreate the test file now with comprehensive test coverage appropriate for the module type."
  }
}